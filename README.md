# cycle-predictor-core

**–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ:** –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –º–µ–¥–∏—Ü–∏–Ω—Å–∫–∏–º –∏–∑–¥–µ–ª–∏–µ–º –∏ –Ω–µ –∑–∞–º–µ–Ω—è–µ—Ç –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏—é –≤—Ä–∞—á–∞. –í—Å–µ –ø—Ä–æ–≥–Ω–æ–∑—ã –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–Ω—ã–µ –∏ –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω—ã —Ç–æ–ª—å–∫–æ –¥–ª—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Ü–µ–ª–µ–π.

[![npm version](https://badge.fury.io/js/cycle-predictor-core.svg)](https://badge.fury.io/js/cycle-predictor-core)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![TypeScript](https://img.shields.io/badge/TypeScript-5.9-blue.svg)](https://www.typescriptlang.org/)

–ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ –¥–ª—è –ø—Ä–æ–≥–Ω–æ–∑–∏—Ä–æ–≤–∞–Ω–∏—è –º–µ–Ω—Å—Ç—Ä—É–∞–ª—å–Ω—ã—Ö —Ü–∏–∫–ª–æ–≤ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö. –ü—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç —Ç–æ—á–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã –¥–ª—è –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è —Å–ª–µ–¥—É—é—â–∏—Ö –º–µ–Ω—Å—Ç—Ä—É–∞—Ü–∏–π, –æ–≤—É–ª—è—Ü–∏–∏ –∏ —Ñ–µ—Ä—Ç–∏–ª—å–Ω—ã—Ö –æ–∫–æ–Ω.

## üöÄ –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏

- **–ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –ø—Ä–æ–≥–Ω–æ–∑–∏—Ä–æ–≤–∞–Ω–∏—è**: Calendar –∏ WMA (Weighted Moving Average)
- **–ê–Ω–∞–ª–∏–∑ –∫–∞—á–µ—Å—Ç–≤–∞ –¥–∞–Ω–Ω—ã—Ö**: –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –æ—Ü–µ–Ω–∫–∞ —Ä–µ–≥—É–ª—è—Ä–Ω–æ—Å—Ç–∏ —Ü–∏–∫–ª–æ–≤
- **–ü—Ä–æ–≥–Ω–æ–∑–∏—Ä–æ–≤–∞–Ω–∏–µ –æ–≤—É–ª—è—Ü–∏–∏**: –Ω–∞ –æ—Å–Ω–æ–≤–µ –ª—é—Ç–µ–∏–Ω–æ–≤–æ–π —Ñ–∞–∑—ã
- **–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ñ–µ—Ä—Ç–∏–ª—å–Ω—ã—Ö –æ–∫–æ–Ω**: –¥–ª—è –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –±–µ—Ä–µ–º–µ–Ω–Ω–æ—Å—Ç–∏
- **–°–∏—Å—Ç–µ–º–∞ —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏**: confidence score –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø—Ä–æ–≥–Ω–æ–∑–∞
- **–†–∞—Å—à–∏—Ä—è–µ–º–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞**: –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –∫–∞—Å—Ç–æ–º–Ω—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤
- **TypeScript –ø–æ–¥–¥–µ—Ä–∂–∫–∞**: –ø–æ–ª–Ω–∞—è —Ç–∏–ø–∏–∑–∞—Ü–∏—è –∏–∑ –∫–æ—Ä–æ–±–∫–∏

## üì¶ –£—Å—Ç–∞–Ω–æ–≤–∫–∞

```bash
npm install cycle-predictor-core
```

```bash
yarn add cycle-predictor-core
```

```bash
pnpm add cycle-predictor-core
```

## üéØ –ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç

### –ë–∞–∑–æ–≤–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ

```typescript
import { PredictionEngine } from "cycle-predictor-core";

const engine = new PredictionEngine({ strategy: "wma" });

const history = {
  periodStarts: [
    { date: "2025-01-02" },
    { date: "2025-01-31" }, // 29 –¥–Ω–µ–π
    { date: "2025-03-01" }, // 29 –¥–Ω–µ–π
    { date: "2025-03-29" }, // 28 –¥–Ω–µ–π
    { date: "2025-04-27" }, // 29 –¥–Ω–µ–π
  ],
};

// –ü—Ä–æ–≥–Ω–æ–∑ —Å–ª–µ–¥—É—é—â–µ–π –º–µ–Ω—Å—Ç—Ä—É–∞—Ü–∏–∏
const nextPeriod = engine.predictNextPeriod(history);
console.log("–°–ª–µ–¥—É—é—â–∞—è –º–µ–Ω—Å—Ç—Ä—É–∞—Ü–∏—è:", nextPeriod.likely);
console.log("–£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å:", Math.round(nextPeriod.confidence * 100) + "%");

// –ü—Ä–æ–≥–Ω–æ–∑ –æ–≤—É–ª—è—Ü–∏–∏
const ovulation = engine.predictOvulation(history);
console.log("–û–≤—É–ª—è—Ü–∏—è:", ovulation.likely);

// –§–µ—Ä—Ç–∏–ª—å–Ω–æ–µ –æ–∫–Ω–æ
const fertile = engine.predictFertileWindow(history);
console.log("–§–µ—Ä—Ç–∏–ª—å–Ω–æ–µ –æ–∫–Ω–æ:", fertile.start, "-", fertile.end);
```

### –ê–Ω–∞–ª–∏–∑ –¥–∞–Ω–Ω—ã—Ö

```typescript
// –ü–æ–ª—É—á–µ–Ω–∏–µ –∞–Ω–∞–ª–∏—Ç–∏—á–µ—Å–∫–æ–π —Å–≤–æ–¥–∫–∏
const summary = engine.analyze(history);
console.log("–°—Ä–µ–¥–Ω—è—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Ü–∏–∫–ª–∞:", summary.averageCycle);
console.log("–†–µ–≥—É–ª—è—Ä–Ω–æ—Å—Ç—å:", summary.irregular ? "–ù–µ—Ä–µ–≥—É–ª—è—Ä–Ω—ã–π" : "–†–µ–≥—É–ª—è—Ä–Ω—ã–π");
console.log("–ö–∞—á–µ—Å—Ç–≤–æ –¥–∞–Ω–Ω—ã—Ö:", summary.dataQuality);
```

## üìö API Reference

### PredictionEngine

–û—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞—Å—Å –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –ø—Ä–æ–≥–Ω–æ–∑–∞–º–∏.

#### –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä

```typescript
new PredictionEngine(config?: PredictorConfig)
```

#### –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è (PredictorConfig)

| –ü–∞—Ä–∞–º–µ—Ç—Ä | –¢–∏–ø | –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é | –û–ø–∏—Å–∞–Ω–∏–µ |
|----------|-----|--------------|----------|
| `strategy` | `'wma' \| 'calendar'` | `'wma'` | –°—Ç—Ä–∞—Ç–µ–≥–∏—è –ø—Ä–æ–≥–Ω–æ–∑–∏—Ä–æ–≤–∞–Ω–∏—è |
| `lutealPhaseDays` | `number` | `14` | –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –ª—é—Ç–µ–∏–Ω–æ–≤–æ–π —Ñ–∞–∑—ã |
| `irregularityStdThreshold` | `number` | `4` | –ü–æ—Ä–æ–≥ –Ω–µ—Ä–µ–≥—É–ª—è—Ä–Ω–æ—Å—Ç–∏ (—Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–∏–µ) |
| `minIntervalsForConfidence` | `number` | `3` | –ú–∏–Ω–∏–º—É–º –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–≤ –¥–ª—è —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç–∏ |
| `timezone` | `string` | –õ–æ–∫–∞–ª—å–Ω–∞—è TZ | –¢–∞–π–º–∑–æ–Ω–∞ –¥–ª—è —Ä–∞—Å—á–µ—Ç–æ–≤ |

#### –ú–µ—Ç–æ–¥—ã

##### `analyze(history: HistoryInput): AnalyticsSummary`

–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–≤–æ–¥–∫—É.

```typescript
const summary = engine.analyze(history);
// {
//   sampleSize: 4,
//   cycleIntervals: [29, 29, 28, 29],
//   averageCycle: 28.75,
//   medianCycle: 29,
//   stdCycle: 0.5,
//   irregular: false,
//   dataQuality: "medium"
// }
```

##### `predictNextPeriod(history: HistoryInput): PredictionResult`

–ü—Ä–æ–≥–Ω–æ–∑–∏—Ä—É–µ—Ç –¥–∞—Ç—É —Å–ª–µ–¥—É—é—â–µ–π –º–µ–Ω—Å—Ç—Ä—É–∞—Ü–∏–∏.

```typescript
const result = engine.predictNextPeriod(history);
// {
//   likely: "2025-05-26",
//   window: { start: "2025-05-24", end: "2025-05-28" },
//   confidence: 0.8,
//   notes: ["wma: weighted last intervals", "irregularity: ¬±2d"]
// }
```

##### `predictOvulation(history: HistoryInput): PredictionResult`

–ü—Ä–æ–≥–Ω–æ–∑–∏—Ä—É–µ—Ç –¥–∞—Ç—É –æ–≤—É–ª—è—Ü–∏–∏.

##### `predictFertileWindow(history: HistoryInput): FertileWindow`

–û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ñ–µ—Ä—Ç–∏–ª—å–Ω–æ–µ –æ–∫–Ω–æ.

```typescript
const fertile = engine.predictFertileWindow(history);
// {
//   start: "2025-05-07",
//   peak: "2025-05-12",
//   end: "2025-05-13",
//   confidence: 0.7,
//   notes: ["ovulation = nextPeriod - lutealPhaseDays", "fertile = ovulation ¬± (‚àí5..+1)"]
// }
```

### –¢–∏–ø—ã –¥–∞–Ω–Ω—ã—Ö

#### HistoryInput

```typescript
interface HistoryInput {
  periodStarts: PeriodStartRecord[];
}

interface PeriodStartRecord {
  date: ISODate; // YYYY-MM-DD
}
```

#### PredictionResult

```typescript
interface PredictionResult {
  likely: ISODate | null;        // –í–µ—Ä–æ—è—Ç–Ω–∞—è –¥–∞—Ç–∞
  window: DateRange | null;      // –û–∫–Ω–æ –ø—Ä–æ–≥–Ω–æ–∑–∞
  confidence: number;            // –£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å (0-1)
  notes: string[];               // –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏
}
```

#### FertileWindow

```typescript
interface FertileWindow {
  start: ISODate;                // –ù–∞—á–∞–ª–æ —Ñ–µ—Ä—Ç–∏–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞
  peak: ISODate;                 // –ü–∏–∫ —Ñ–µ—Ä—Ç–∏–ª—å–Ω–æ—Å—Ç–∏ (–æ–≤—É–ª—è—Ü–∏—è)
  end: ISODate;                  // –ö–æ–Ω–µ—Ü —Ñ–µ—Ä—Ç–∏–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞
  confidence: number;            // –£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å
  notes: string[];               // –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏
}
```

## üé® –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å UI —Ñ—Ä–µ–π–º–≤–æ—Ä–∫–∞–º–∏

### React/Next.js

#### –•—É–∫ –¥–ª—è –ø—Ä–æ–≥–Ω–æ–∑–æ–≤

```typescript
import { useState, useEffect } from 'react';
import { PredictionEngine, HistoryInput } from 'cycle-predictor-core';

const useCyclePredictions = (history: HistoryInput) => {
  const [predictions, setPredictions] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  useEffect(() => {
    if (history.periodStarts.length >= 2) {
      setLoading(true);
      setError(null);
      
      try {
        const engine = new PredictionEngine({ strategy: 'wma' });
        
        const nextPeriod = engine.predictNextPeriod(history);
        const ovulation = engine.predictOvulation(history);
        const fertile = engine.predictFertileWindow(history);
        const summary = engine.analyze(history);
        
        setPredictions({ nextPeriod, ovulation, fertile, summary });
      } catch (err) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }
  }, [history]);

  return { predictions, loading, error };
};
```

#### –ö–æ–º–ø–æ–Ω–µ–Ω—Ç –∫–∞–ª–µ–Ω–¥–∞—Ä—è

```typescript
import React from 'react';
import { useCyclePredictions } from './hooks/useCyclePredictions';

interface CycleCalendarProps {
  periodHistory: HistoryInput;
}

const CycleCalendar: React.FC<CycleCalendarProps> = ({ periodHistory }) => {
  const { predictions, loading, error } = useCyclePredictions(periodHistory);

  if (loading) return <div>–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ...</div>;
  if (error) return <div>–û—à–∏–±–∫–∞: {error}</div>;
  if (!predictions) return <div>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø—Ä–æ–≥–Ω–æ–∑–∞</div>;

  return (
    <div className="cycle-calendar">
      <div className="prediction-card">
        <h3>–°–ª–µ–¥—É—é—â–∞—è –º–µ–Ω—Å—Ç—Ä—É–∞—Ü–∏—è</h3>
        <div className="date">{predictions.nextPeriod.likely}</div>
        <div className="confidence">
          –£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {Math.round(predictions.nextPeriod.confidence * 100)}%
        </div>
        {predictions.nextPeriod.window && (
          <div className="window">
            –û–∫–Ω–æ: {predictions.nextPeriod.window.start} - {predictions.nextPeriod.window.end}
          </div>
        )}
      </div>

      <div className="prediction-card">
        <h3>–û–≤—É–ª—è—Ü–∏—è</h3>
        <div className="date">{predictions.ovulation.likely}</div>
        <div className="confidence">
          –£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {Math.round(predictions.ovulation.confidence * 100)}%
        </div>
      </div>

      <div className="prediction-card">
        <h3>–§–µ—Ä—Ç–∏–ª—å–Ω–æ–µ –æ–∫–Ω–æ</h3>
        <div className="fertile-range">
          {predictions.fertile.start} - {predictions.fertile.end}
        </div>
        <div className="peak">–ü–∏–∫: {predictions.fertile.peak}</div>
      </div>

      <div className="analytics">
        <h3>–ê–Ω–∞–ª–∏–∑ –¥–∞–Ω–Ω—ã—Ö</h3>
        <p>–°—Ä–µ–¥–Ω–∏–π —Ü–∏–∫–ª: {predictions.summary.averageCycle} –¥–Ω–µ–π</p>
        <p>–†–µ–≥—É–ª—è—Ä–Ω–æ—Å—Ç—å: {predictions.summary.irregular ? '–ù–µ—Ä–µ–≥—É–ª—è—Ä–Ω—ã–π' : '–†–µ–≥—É–ª—è—Ä–Ω—ã–π'}</p>
        <p>–ö–∞—á–µ—Å—Ç–≤–æ –¥–∞–Ω–Ω—ã—Ö: {predictions.summary.dataQuality}</p>
      </div>
    </div>
  );
};
```

### Vue.js

#### Composition API

```typescript
<template>
  <div class="cycle-predictor">
    <div v-if="loading">–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ...</div>
    <div v-else-if="error">–û—à–∏–±–∫–∞: {{ error }}</div>
    <div v-else-if="predictions" class="predictions">
      <div class="prediction-card">
        <h3>–°–ª–µ–¥—É—é—â–∞—è –º–µ–Ω—Å—Ç—Ä—É–∞—Ü–∏—è</h3>
        <p>{{ predictions.nextPeriod.likely }}</p>
        <p>–£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {{ Math.round(predictions.nextPeriod.confidence * 100) }}%</p>
      </div>
      
      <div class="prediction-card">
        <h3>–û–≤—É–ª—è—Ü–∏—è</h3>
        <p>{{ predictions.ovulation.likely }}</p>
      </div>
      
      <div class="prediction-card">
        <h3>–§–µ—Ä—Ç–∏–ª—å–Ω–æ–µ –æ–∫–Ω–æ</h3>
        <p>{{ predictions.fertile.start }} - {{ predictions.fertile.end }}</p>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed, watch } from 'vue';
import { PredictionEngine, type HistoryInput } from 'cycle-predictor-core';

const props = defineProps<{
  periodHistory: HistoryInput;
}>();

const predictions = ref(null);
const loading = ref(false);
const error = ref(null);

const calculatePredictions = async () => {
  if (props.periodHistory.periodStarts.length < 2) {
    predictions.value = null;
    return;
  }

  loading.value = true;
  error.value = null;

  try {
    const engine = new PredictionEngine({ strategy: 'wma' });
    predictions.value = {
      nextPeriod: engine.predictNextPeriod(props.periodHistory),
      ovulation: engine.predictOvulation(props.periodHistory),
      fertile: engine.predictFertileWindow(props.periodHistory),
      summary: engine.analyze(props.periodHistory)
    };
  } catch (err) {
    error.value = err.message;
  } finally {
    loading.value = false;
  }
};

watch(() => props.periodHistory, calculatePredictions, { immediate: true });
</script>
```

### Angular

#### –°–µ—Ä–≤–∏—Å

```typescript
import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable } from 'rxjs';
import { PredictionEngine, type HistoryInput, type PredictionResult } from 'cycle-predictor-core';

export interface CyclePredictions {
  nextPeriod: PredictionResult;
  ovulation: PredictionResult;
  fertile: any;
  summary: any;
}

@Injectable({
  providedIn: 'root'
})
export class CyclePredictionService {
  private engine = new PredictionEngine({ strategy: 'wma' });
  private predictionsSubject = new BehaviorSubject<CyclePredictions | null>(null);
  private loadingSubject = new BehaviorSubject<boolean>(false);

  predictions$ = this.predictionsSubject.asObservable();
  loading$ = this.loadingSubject.asObservable();

  calculatePredictions(history: HistoryInput): void {
    if (history.periodStarts.length < 2) {
      this.predictionsSubject.next(null);
      return;
    }

    this.loadingSubject.next(true);

    try {
      const predictions = {
        nextPeriod: this.engine.predictNextPeriod(history),
        ovulation: this.engine.predictOvulation(history),
        fertile: this.engine.predictFertileWindow(history),
        summary: this.engine.analyze(history)
      };

      this.predictionsSubject.next(predictions);
    } catch (error) {
      console.error('–û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ –ø—Ä–æ–≥–Ω–æ–∑–æ–≤:', error);
    } finally {
      this.loadingSubject.next(false);
    }
  }
}
```

#### –ö–æ–º–ø–æ–Ω–µ–Ω—Ç

```typescript
import { Component, Input, OnInit } from '@angular/core';
import { CyclePredictionService, type CyclePredictions } from './cycle-prediction.service';
import { type HistoryInput } from 'cycle-predictor-core';

@Component({
  selector: 'app-cycle-predictor',
  template: `
    <div class="cycle-predictor">
      <div *ngIf="loading$ | async" class="loading">
        –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ...
      </div>
      
      <div *ngIf="predictions$ | async as predictions" class="predictions">
        <div class="prediction-card">
          <h3>–°–ª–µ–¥—É—é—â–∞—è –º–µ–Ω—Å—Ç—Ä—É–∞—Ü–∏—è</h3>
          <p class="date">{{ predictions.nextPeriod.likely }}</p>
          <p class="confidence">
            –£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {{ (predictions.nextPeriod.confidence * 100) | number:'1.0-0' }}%
          </p>
        </div>
        
        <div class="prediction-card">
          <h3>–û–≤—É–ª—è—Ü–∏—è</h3>
          <p class="date">{{ predictions.ovulation.likely }}</p>
        </div>
        
        <div class="prediction-card">
          <h3>–§–µ—Ä—Ç–∏–ª—å–Ω–æ–µ –æ–∫–Ω–æ</h3>
          <p class="range">{{ predictions.fertile.start }} - {{ predictions.fertile.end }}</p>
          <p class="peak">–ü–∏–∫: {{ predictions.fertile.peak }}</p>
        </div>
      </div>
    </div>
  `,
  styleUrls: ['./cycle-predictor.component.scss']
})
export class CyclePredictorComponent implements OnInit {
  @Input() periodHistory!: HistoryInput;

  predictions$ = this.predictionService.predictions$;
  loading$ = this.predictionService.loading$;

  constructor(private predictionService: CyclePredictionService) {}

  ngOnInit() {
    this.predictionService.calculatePredictions(this.periodHistory);
  }
}
```

## üì± –ú–æ–±–∏–ª—å–Ω—ã–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è

### React Native

```typescript
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { PredictionEngine, type HistoryInput } from 'cycle-predictor-core';

interface CyclePredictorProps {
  periodHistory: HistoryInput;
}

const CyclePredictor: React.FC<CyclePredictorProps> = ({ periodHistory }) => {
  const [predictions, setPredictions] = React.useState(null);
  const [loading, setLoading] = React.useState(false);

  React.useEffect(() => {
    if (periodHistory.periodStarts.length >= 2) {
      setLoading(true);
      
      const engine = new PredictionEngine({ strategy: 'wma' });
      const nextPeriod = engine.predictNextPeriod(periodHistory);
      const ovulation = engine.predictOvulation(periodHistory);
      const fertile = engine.predictFertileWindow(periodHistory);
      
      setPredictions({ nextPeriod, ovulation, fertile });
      setLoading(false);
    }
  }, [periodHistory]);

  if (loading) {
    return (
      <View style={styles.container}>
        <Text>–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ...</Text>
      </View>
    );
  }

  if (!predictions) {
    return (
      <View style={styles.container}>
        <Text>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø—Ä–æ–≥–Ω–æ–∑–∞</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <View style={styles.card}>
        <Text style={styles.title}>–°–ª–µ–¥—É—é—â–∞—è –º–µ–Ω—Å—Ç—Ä—É–∞—Ü–∏—è</Text>
        <Text style={styles.date}>{predictions.nextPeriod.likely}</Text>
        <Text style={styles.confidence}>
          –£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {Math.round(predictions.nextPeriod.confidence * 100)}%
        </Text>
      </View>
      
      <View style={styles.card}>
        <Text style={styles.title}>–û–≤—É–ª—è—Ü–∏—è</Text>
        <Text style={styles.date}>{predictions.ovulation.likely}</Text>
      </View>
      
      <View style={styles.card}>
        <Text style={styles.title}>–§–µ—Ä—Ç–∏–ª—å–Ω–æ–µ –æ–∫–Ω–æ</Text>
        <Text style={styles.range}>
          {predictions.fertile.start} - {predictions.fertile.end}
        </Text>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 16,
  },
  card: {
    backgroundColor: '#fff',
    padding: 16,
    marginBottom: 12,
    borderRadius: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
    elevation: 3,
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  date: {
    fontSize: 16,
    color: '#333',
  },
  confidence: {
    fontSize: 14,
    color: '#666',
    marginTop: 4,
  },
  range: {
    fontSize: 16,
    color: '#333',
  },
});

export default CyclePredictor;
```

## üîß –†–∞—Å—à–∏—Ä–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏

### –°–æ–∑–¥–∞–Ω–∏–µ –∫–∞—Å—Ç–æ–º–Ω—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤

```typescript
import { BaseRule, type HistoryInput, type PredictionResult, type PredictorConfig, type AnalyticsSummary } from 'cycle-predictor-core';

class MLPredictionRule extends BaseRule {
  readonly id = 'ml-prediction';

  predictNextPeriod(
    history: HistoryInput,
    cfg: Required<PredictorConfig>,
    summary: AnalyticsSummary
  ): PredictionResult {
    // –í–∞—à–∞ ML –ª–æ–≥–∏–∫–∞ –∑–¥–µ—Å—å
    const mlPrediction = this.runMLModel(history, summary);
    
    return {
      likely: mlPrediction.date,
      window: {
        start: mlPrediction.startDate,
        end: mlPrediction.endDate
      },
      confidence: mlPrediction.confidence,
      notes: ['ML-based prediction', `model: ${mlPrediction.modelName}`]
    };
  }

  private runMLModel(history: HistoryInput, summary: AnalyticsSummary) {
    // –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –≤–∞—à–µ–π ML –º–æ–¥–µ–ª—å—é
    // –ù–∞–ø—Ä–∏–º–µ—Ä, TensorFlow.js, ONNX.js, –∏–ª–∏ –≤–Ω–µ—à–Ω–∏–π API
    return {
      date: '2025-06-15',
      startDate: '2025-06-13',
      endDate: '2025-06-17',
      confidence: 0.85,
      modelName: 'cycle-predictor-v1'
    };
  }
}

// –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –≤ –¥–≤–∏–∂–∫–µ
const engine = new PredictionEngine();
engine.register(new MLPredictionRule());

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
const result = engine.predictNextPeriod(history);
```

### –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –≤–Ω–µ—à–Ω–∏–º–∏ –¥–∞–Ω–Ω—ã–º–∏

```typescript
class EnhancedPredictionEngine extends PredictionEngine {
  async predictWithExternalFactors(history: HistoryInput) {
    const basePrediction = this.predictNextPeriod(history);
    
    // –ü–æ–ª—É—á–∞–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ñ–∞–∫—Ç–æ—Ä—ã
    const weatherData = await this.getWeatherData();
    const stressLevel = await this.getStressLevel();
    const sleepQuality = await this.getSleepQuality();
    
    // –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –ø—Ä–æ–≥–Ω–æ–∑
    return this.adjustPrediction(basePrediction, {
      weather: weatherData,
      stress: stressLevel,
      sleep: sleepQuality
    });
  }

  private adjustPrediction(basePrediction: PredictionResult, factors: any) {
    let adjustedConfidence = basePrediction.confidence;
    const notes = [...basePrediction.notes];

    // –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä–æ–≤–∫–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ñ–∞–∫—Ç–æ—Ä–æ–≤
    if (factors.stress > 7) {
      adjustedConfidence *= 0.9;
      notes.push('high stress detected');
    }

    if (factors.sleep < 6) {
      adjustedConfidence *= 0.95;
      notes.push('poor sleep quality');
    }

    return {
      ...basePrediction,
      confidence: Math.max(0.1, adjustedConfidence),
      notes
    };
  }
}
```

## üóÑÔ∏è –†–∞–±–æ—Ç–∞ —Å –¥–∞–Ω–Ω—ã–º–∏

### –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏ –∑–∞–≥—Ä—É–∑–∫–∞

```typescript
class CycleDataService {
  private readonly STORAGE_KEY = 'cycle_history';
  private readonly PREDICTIONS_KEY = 'cycle_predictions';

  async savePeriodDate(date: string): Promise<void> {
    const history = await this.loadHistory();
    history.periodStarts.push({ date });
    await this.saveHistory(history);
    
    // –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –ø—Ä–æ–≥–Ω–æ–∑—ã
    const engine = new PredictionEngine();
    const predictions = engine.predictNextPeriod(history);
    await this.savePredictions(predictions);
  }

  async loadHistory(): Promise<HistoryInput> {
    const stored = localStorage.getItem(this.STORAGE_KEY);
    return stored ? JSON.parse(stored) : { periodStarts: [] };
  }

  async saveHistory(history: HistoryInput): Promise<void> {
    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(history));
  }

  async getCurrentPredictions(): Promise<any> {
    const history = await this.loadHistory();
    const engine = new PredictionEngine();
    
    return {
      nextPeriod: engine.predictNextPeriod(history),
      ovulation: engine.predictOvulation(history),
      fertile: engine.predictFertileWindow(history),
      summary: engine.analyze(history)
    };
  }
}
```

### –≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö

```typescript
class DataExportService {
  exportToCSV(history: HistoryInput): string {
    const headers = ['Date', 'Cycle Length'];
    const rows = [];
    
    for (let i = 1; i < history.periodStarts.length; i++) {
      const prev = new Date(history.periodStarts[i - 1].date);
      const curr = new Date(history.periodStarts[i].date);
      const cycleLength = Math.round((curr.getTime() - prev.getTime()) / (1000 * 60 * 60 * 24));
      
      rows.push([history.periodStarts[i].date, cycleLength]);
    }
    
    return [headers, ...rows]
      .map(row => row.join(','))
      .join('\n');
  }

  exportToJSON(history: HistoryInput, predictions: any): string {
    return JSON.stringify({
      history,
      predictions,
      exportDate: new Date().toISOString()
    }, null, 2);
  }
}
```

## üß™ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ

### Unit —Ç–µ—Å—Ç—ã

```typescript
import { PredictionEngine } from 'cycle-predictor-core';

describe('PredictionEngine', () => {
  let engine: PredictionEngine;

  beforeEach(() => {
    engine = new PredictionEngine({ strategy: 'wma' });
  });

  it('should predict next period correctly', () => {
    const history = {
      periodStarts: [
        { date: '2025-01-01' },
        { date: '2025-01-30' }, // 29 –¥–Ω–µ–π
        { date: '2025-02-28' }, // 29 –¥–Ω–µ–π
      ]
    };

    const result = engine.predictNextPeriod(history);
    
    expect(result.likely).toBeTruthy();
    expect(result.confidence).toBeGreaterThan(0);
    expect(result.confidence).toBeLessThanOrEqual(1);
  });

  it('should handle irregular cycles', () => {
    const history = {
      periodStarts: [
        { date: '2025-01-01' },
        { date: '2025-01-25' }, // 24 –¥–Ω—è
        { date: '2025-02-28' }, // 33 –¥–Ω—è
        { date: '2025-03-25' }, // 25 –¥–Ω–µ–π
      ]
    };

    const summary = engine.analyze(history);
    expect(summary.irregular).toBe(true);
  });
});
```

### Integration —Ç–µ—Å—Ç—ã

```typescript
describe('Cycle Prediction Integration', () => {
  it('should provide consistent predictions across methods', () => {
    const engine = new PredictionEngine();
    const history = {
      periodStarts: [
        { date: '2025-01-01' },
        { date: '2025-01-30' },
        { date: '2025-02-28' },
        { date: '2025-03-29' },
      ]
    };

    const nextPeriod = engine.predictNextPeriod(history);
    const ovulation = engine.predictOvulation(history);
    const fertile = engine.predictFertileWindow(history);

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–æ–≥–∏—á–µ—Å–∫—É—é —Å–≤—è–∑—å –º–µ–∂–¥—É –ø—Ä–æ–≥–Ω–æ–∑–∞–º–∏
    expect(nextPeriod.likely).toBeTruthy();
    expect(ovulation.likely).toBeTruthy();
    expect(fertile.start).toBeTruthy();
    expect(fertile.end).toBeTruthy();
  });
});
```

## üöÄ –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å

### –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –¥–ª—è –±–æ–ª—å—à–∏—Ö –æ–±—ä–µ–º–æ–≤ –¥–∞–Ω–Ω—ã—Ö

```typescript
class OptimizedPredictionEngine extends PredictionEngine {
  private cache = new Map<string, any>();

  predictNextPeriod(history: HistoryInput): PredictionResult {
    const cacheKey = this.generateCacheKey(history);
    
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }

    const result = super.predictNextPeriod(history);
    this.cache.set(cacheKey, result);
    
    return result;
  }

  private generateCacheKey(history: HistoryInput): string {
    return JSON.stringify(history.periodStarts.map(p => p.date));
  }

  clearCache(): void {
    this.cache.clear();
  }
}
```

### Web Worker –¥–ª—è —Ç—è–∂–µ–ª—ã—Ö –≤—ã—á–∏—Å–ª–µ–Ω–∏–π

```typescript
// worker.ts
import { PredictionEngine } from 'cycle-predictor-core';

self.onmessage = (event) => {
  const { history, config } = event.data;
  
  try {
    const engine = new PredictionEngine(config);
    const predictions = {
      nextPeriod: engine.predictNextPeriod(history),
      ovulation: engine.predictOvulation(history),
      fertile: engine.predictFertileWindow(history),
      summary: engine.analyze(history)
    };
    
    self.postMessage({ success: true, predictions });
  } catch (error) {
    self.postMessage({ success: false, error: error.message });
  }
};

// main.ts
const worker = new Worker('./worker.js');

worker.onmessage = (event) => {
  if (event.data.success) {
    setPredictions(event.data.predictions);
  } else {
    setError(event.data.error);
  }
};

const calculatePredictions = (history: HistoryInput) => {
  worker.postMessage({ history, config: { strategy: 'wma' } });
};
```

## üîí –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∏ –ø—Ä–∏–≤–∞—Ç–Ω–æ—Å—Ç—å

### –õ–æ–∫–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö

```typescript
class PrivacyAwarePredictionEngine extends PredictionEngine {
  // –í—Å–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –ø—Ä–æ–∏—Å—Ö–æ–¥—è—Ç –ª–æ–∫–∞–ª—å–Ω–æ
  // –î–∞–Ω–Ω—ã–µ –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª—è—é—Ç—Å—è –Ω–∞ —Å–µ—Ä–≤–µ—Ä
  
  predictNextPeriod(history: HistoryInput): PredictionResult {
    // –õ–æ–∫–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞
    return super.predictNextPeriod(history);
  }
}
```

### –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö

```typescript
import CryptoJS from 'crypto-js';

class EncryptedDataService {
  private readonly SECRET_KEY = 'your-secret-key';

  encryptData(data: any): string {
    return CryptoJS.AES.encrypt(JSON.stringify(data), this.SECRET_KEY).toString();
  }

  decryptData(encryptedData: string): any {
    const bytes = CryptoJS.AES.decrypt(encryptedData, this.SECRET_KEY);
    return JSON.parse(bytes.toString(CryptoJS.enc.Utf8));
  }

  async saveEncryptedHistory(history: HistoryInput): Promise<void> {
    const encrypted = this.encryptData(history);
    localStorage.setItem('encrypted_cycle_data', encrypted);
  }

  async loadEncryptedHistory(): Promise<HistoryInput> {
    const encrypted = localStorage.getItem('encrypted_cycle_data');
    if (!encrypted) return { periodStarts: [] };
    
    return this.decryptData(encrypted);
  }
}
```

## üìä –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ –∞–Ω–∞–ª–∏—Ç–∏–∫–∞

### –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è

```typescript
class AnalyticsService {
  logPredictionRequest(history: HistoryInput, predictions: any): void {
    const event = {
      timestamp: new Date().toISOString(),
      dataPoints: history.periodStarts.length,
      predictionType: 'cycle',
      confidence: predictions.nextPeriod.confidence,
      irregular: predictions.summary.irregular
    };

    // –û—Ç–ø—Ä–∞–≤–∫–∞ –≤ –∞–Ω–∞–ª–∏—Ç–∏—á–µ—Å–∫—É—é —Å–∏—Å—Ç–µ–º—É
    this.sendAnalytics(event);
  }

  private sendAnalytics(event: any): void {
    // –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å Google Analytics, Mixpanel, etc.
    if (typeof gtag !== 'undefined') {
      gtag('event', 'cycle_prediction', event);
    }
  }
}
```

## ü§ù –í–∫–ª–∞–¥ –≤ —Ä–∞–∑–≤–∏—Ç–∏–µ

### –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏

```bash
git clone https://github.com/your-username/cycle-predictor-core.git
cd cycle-predictor-core
npm install
npm run test
```

### –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞

```
cycle-predictor-core/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ core/           # –û—Å–Ω–æ–≤–Ω–∞—è –ª–æ–≥–∏–∫–∞
‚îÇ   ‚îú‚îÄ‚îÄ plugins/        # –ê–ª–≥–æ—Ä–∏—Ç–º—ã –ø—Ä–æ–≥–Ω–æ–∑–∏—Ä–æ–≤–∞–Ω–∏—è
‚îÇ   ‚îú‚îÄ‚îÄ utils/          # –£—Ç–∏–ª–∏—Ç—ã
‚îÇ   ‚îú‚îÄ‚îÄ types.ts        # TypeScript —Ç–∏–ø—ã
‚îÇ   ‚îî‚îÄ‚îÄ index.ts        # –¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞
‚îú‚îÄ‚îÄ tests/              # –¢–µ—Å—Ç—ã
‚îú‚îÄ‚îÄ docs/               # –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è
‚îî‚îÄ‚îÄ examples/           # –ü—Ä–∏–º–µ—Ä—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
```

### –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤—ã—Ö –∞–ª–≥–æ—Ä–∏—Ç–º–æ–≤

1. –°–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤—ã–π –∫–ª–∞—Å—Å, –Ω–∞—Å–ª–µ–¥—É—é—â–∏–π –æ—Ç `BaseRule`
2. –†–µ–∞–ª–∏–∑—É–π—Ç–µ –º–µ—Ç–æ–¥—ã `predictNextPeriod` –∏ `predictFertility`
3. –î–æ–±–∞–≤—å—Ç–µ —Ç–µ—Å—Ç—ã
4. –û–±–Ω–æ–≤–∏—Ç–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é

```typescript
// src/plugins/yourAlgorithm.ts
import { BaseRule } from './baseRule';

export class YourAlgorithm extends BaseRule {
  readonly id = 'your-algorithm';

  predictNextPeriod(history, cfg, summary) {
    // –í–∞—à–∞ –ª–æ–≥–∏–∫–∞
    return {
      likely: '2025-06-15',
      window: { start: '2025-06-13', end: '2025-06-17' },
      confidence: 0.8,
      notes: ['your algorithm']
    };
  }
}
```

### –û—Ç–ø—Ä–∞–≤–∫–∞ Pull Request

1. –§–æ—Ä–∫–Ω–∏—Ç–µ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π
2. –°–æ–∑–¥–∞–π—Ç–µ –≤–µ—Ç–∫—É –¥–ª—è –≤–∞—à–µ–π —Ñ—É–Ω–∫—Ü–∏–∏
3. –î–æ–±–∞–≤—å—Ç–µ —Ç–µ—Å—Ç—ã
4. –û–±–Ω–æ–≤–∏—Ç–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é
5. –û—Ç–ø—Ä–∞–≤—å—Ç–µ Pull Request

## üìà Roadmap

### –ü–ª–∞–Ω–∏—Ä—É–µ–º—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏

- [ ] –ú–∞—à–∏–Ω–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è —Ç–æ—á–Ω–æ—Å—Ç–∏
- [ ] –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –Ω–æ—Å–∏–º—ã–º–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞–º–∏
- [ ] –ü–æ–¥–¥–µ—Ä–∂–∫–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
- [ ] API –¥–ª—è —Å–µ—Ä–≤–µ—Ä–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
- [ ] –ü–ª–∞–≥–∏–Ω—ã –¥–ª—è –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö —Ñ—Ä–µ–π–º–≤–æ—Ä–∫–æ–≤
- [ ] –ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è —Å –º–µ–¥–∏—Ü–∏–Ω—Å–∫–∏–º–∏ —Å–∏—Å—Ç–µ–º–∞–º–∏

### –í–µ—Ä—Å–∏–∏

- **v1.0.0** - –ë–∞–∑–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å
- **v1.1.0** - –£–ª—É—á—à–µ–Ω–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã
- **v2.0.0** - ML –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è
- **v2.1.0** - API –∏ —Å–µ—Ä–≤–µ—Ä–Ω–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞

## üìû –ü–æ–¥–¥–µ—Ä–∂–∫–∞

- **Issues**: [GitHub Issues](https://github.com/your-username/cycle-predictor-core/issues)
- **Discussions**: [GitHub Discussions](https://github.com/your-username/cycle-predictor-core/discussions)
- **Email**: support@cycle-predictor.com

## üìÑ –õ–∏—Ü–µ–Ω–∑–∏—è

MIT License - —Å–º. —Ñ–∞–π–ª [LICENSE](LICENSE) –¥–ª—è –¥–µ—Ç–∞–ª–µ–π.

---

**–í–∞–∂–Ω–æ**: –≠—Ç–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω–∞ —Ç–æ–ª—å–∫–æ –¥–ª—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Ü–µ–ª–µ–π –∏ –Ω–µ –∑–∞–º–µ–Ω—è–µ—Ç –º–µ–¥–∏—Ü–∏–Ω—Å–∫—É—é –∫–æ–Ω—Å—É–ª—å—Ç–∞—Ü–∏—é. –í—Å–µ–≥–¥–∞ –∫–æ–Ω—Å—É–ª—å—Ç–∏—Ä—É–π—Ç–µ—Å—å —Å –≤—Ä–∞—á–æ–º –ø–æ –≤–æ–ø—Ä–æ—Å–∞–º –∑–¥–æ—Ä–æ–≤—å—è.
